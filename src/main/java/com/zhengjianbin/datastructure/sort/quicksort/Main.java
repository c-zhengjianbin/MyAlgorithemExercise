package com.zhengjianbin.datastructure.sort.quicksort;

/**
 * Created by zhengjianbin on 2019/9/3.
 */
public class Main {

    /**
     * 思路：
     *   首先需要明确，快速排序的原理是什么？
     *   给定一个未排序的数组，在开始下标s、结束下标e 之间任选一个元素pivot，遍历s ~ e 之间的元素，小于
     * pivot 的元素放到pivot 左边，大于pivot 的元素放到右边，遍历结束后使得：pivot 左边都是小于pivot 的
     * 元素，右边都是大于pivot 的元素。采用递归方式，不断对左、右两边元素采用上述逻辑进行比较，左、右，两边
     * 元素不足以递归时，结束。
     *   我们来解读一下上述原理。可以看出，快排包括两步操作：选出pivot 元素并将它放到合适位置；对左、右两边
     * 元素进行递归调用检查。快速排序与归并排序类似，都是分治思想来解决问题。我们先写出它的递推公式：quickSort(s...e)=
     * quickSort(s, pivotIndex) + quick(pivotIndex + 1, e)。可以看出，对于左、右两边递归调用比较简单。
     * 难点在于选出pivot 元素并将它放到合适的位置。一旦涉及将元素放到数组中合适的位置，就需要移动数组内的数据，
     * 以实现数组内数据的连续性。
     *   对于选取pivot 元素，默认选数组中最后一个元素。首先将数组内元素进行划分，分为已处理、未处理。这个区域
     * 的划分，并不是使用格外的数组进行存储，因为那样快速排序的空间复杂度将会上升。这里的划分只是逻辑上的划分，
     * 指定下标内的元素为已处理，下标外的元素为未处理。划分处理方式有点像选择排序，第一个元素下标默认已处理，第
     * 二个元素以后为未处理。
     */
    public static void main(){

    }

}
