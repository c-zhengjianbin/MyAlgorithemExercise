## 一、Semaphore 翻译

### 1.1&emsp;类文档翻译

&emsp;&emsp;一个计数信号量。概念上，一个信号量，维护着一组许可。执行acquire() 方法未获取到许可时会产生阻塞，直到获取一个许可并使用它。执行release() 方法会添加一个许可，可能也会释放正
在阻塞且尝试获取许可的线程。

&emsp;&emsp;如果目前没有对象使用许可。它会保持一个可获得许可的数量。

&emsp;&emsp;信号量总是能够限制一定数量的线程去访问资源。举个例子：这里有一个类使用了Semaphore 来控制访问一个池子中的元素。

&emsp;&emsp;在获取一个元素之前，必须通过acquire() 方法获取一个信号量，保证这个元素是可用的。当线成结束元素访问的时候，会将元素返回到池中，
并且返回一个信号量，允许另一个线程获取这个信号量。注意，当调用acquire() 时，它不会保持同步锁，那样会阻止一个元素返回到池中（也就是说，获取许可
与元素返回到池中是异步的）。信号量封装了限制访问池中元素时所需的同步，与维护池本身一致性所需的任何同步分开。

&emsp;&emsp;一个信号量可以初始化成只包含一个许可，这样可以用来实现互斥锁。这通常被称为二进制信号量，因为它只有两个状态，一个许可，零个许可。 以这样的方式使用时，二进制信号量具有这样的属性（
它和java.util.concurrent.locks.Lock 有些不同），它的锁。能够被另一个线程的所有者释放，（在信号量中没有"所有者"的概念）。这在一些特殊的上下文中很有用，例如：死锁的恢复。

&emsp;&emsp;这个类的构造函数随意的接受一个公平的参数。当设置成false 的时候，这个类不能保证调用acquire的有序性。也就是说，一个线程调用acquire 方法时，会在其他线程等待的前面被分配到许可。逻辑上
新线程会在等待队列的头部。当设置成true 的时候，它会保证所有调用acquire 的顺序，并按照调用顺序分配许可（遵循先进先出的选择）。 注意，FIFO 顺序是必须的，它适用于内部特殊的执行点。


&emsp;&emsp;所以，当一个线程在另一个线程之前调用acquire，但到达指定点的顺序可能在另一个线程后面。另外注意，不定时的tryAcquire 方法是不尊重公平性的，它可以获取任何可用的许可。
 
&emsp;&emsp;通常，信号量用来控制访问资源时，应该将它初始化为公平的。以确保没有线程在访问资源时，不会产生饥饿问题。当使用信号量进行其它类型的同步控制时，非公平的排序吞吐量要超过公平性的考虑。
 
&emsp;&emsp;这个类在获取、释放多个许可时提供了便捷的方法如：acquire、release。当使用这些方法时，如果没有设置为公平，小心这些方法的调用会被无限的风险。（为什么会存在这种风险呢？如果不设置为公平，获取许可
的顺序就乱了，谁也无法保证下一个获取许可的方法将执行。）
 
&emsp;&emsp;内存一致性的影响:对于一个线程调用release()方法，一定会发生在另一个调用acquire() 方法之前。

### 1.2&emsp;方法文档翻译

&emsp;&emsp;acquire():从信号量中返回一个许可，阻塞至获取到一个许可或当线程被中断时。获取一个许可，如果是可获得的，立刻返回，可获取的许可数量减1。如果没有许可是可获取的，当前线程会被禁用以实现线程调度，
该线程会被休眠，直到发生以下两种情况之一，结束休眠：
&emsp;&emsp;其他线程在这个信号量上调用release 方法，当前线程会被分配许可。或者线程中断当前线程。
&emsp;&emsp;进入此方法时设置其中断状态，或者等待一个许可时，然后抛出并清除当前线程的中断状态。